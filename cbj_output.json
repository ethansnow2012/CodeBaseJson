[
    {
        "path": "C:\\Users\\ethan\\Desktop\\code\\my\\cbp\\package.json",
        "content": {
            "name": "cbj",
            "version": "0.0.3",
            "description": "",
            "main": "dist/index.js",
            "bin": {
                "cbj": "./dist/index.js"
            },
            "scripts": {
                "build": "tsc",
                "test": "echo \"Error: no test specified\" && exit 1"
            },
            "keywords": [],
            "author": "",
            "license": "MIT",
            "devDependencies": {
                "@types/node": "^20.11.25",
                "ts-node": "^10.9.2",
                "typescript": "^5.4.2"
            },
            "dependencies": {
                "cbj": "^0.0.3",
                "ignore": "^5.3.1"
            }
        }
    },
    {
        "path": "C:\\Users\\ethan\\Desktop\\code\\my\\cbp\\src\\index.ts",
        "content": "#!/usr/bin/env node\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport ignore from 'ignore';\n\nlet cbjConfig = {\n  dirPath: './',\n  outputFileName: 'cbj_output.json'\n};\n\ntype Ignore = ReturnType<typeof ignore>;\n\ntry {\n    const configPath = process.cwd()+'\\\\cbj.config.js'\n    console.log('trying to read configModule:', configPath);\n    const configModule = require(configPath);\n    if(configModule){\n        console.log('Config module read.');\n    }\n    cbjConfig = configModule || cbjConfig;\n    console.log('Config module read.', cbjConfig);\n    \n} catch (error) {\n  console.log('No cbj.config.ts found, using default configuration.', error);\n}\n\ninterface FileData {\n    path: string;\n    content: string;\n}\n\nfunction readGitignore(): string[] {\n    const forceIgnorePath = ['.git', '.gitignore', 'node_modules', 'dist', 'build', 'out', 'coverage', 'cbj_output.json', 'cbj.config.js', '*-lock.yaml']\n    const gitignorePath = '.gitignore';\n    console.log('reading gitignorePath:', gitignorePath);\n    if (fs.existsSync(gitignorePath)) {\n        return forceIgnorePath.concat(fs.readFileSync(gitignorePath, 'utf8').split('\\n'));\n    }\n    return forceIgnorePath;\n}\n\nfunction readFilesRecursively(dir: string, ig: Ignore): FileData[] {\n    let results: FileData[] = [];\n\n    fs.readdirSync(dir).forEach(file => {\n        file = path.resolve(dir, file);\n        if (ig.ignores(path.relative(cbjConfig.dirPath, file))) {\n            return;\n        }\n        const stat = fs.statSync(file);\n\n        if (stat && stat.isDirectory()) {\n            results = results.concat(readFilesRecursively(file, ig));\n        } else {\n            results.push({\n                path: file,\n                content: fs.readFileSync(file, 'utf8')\n            });\n        }\n    });\n\n    return results;\n}\n\n// New code for handling compress and decompress commands\nconst args = process.argv.slice(2);\n\nfunction compress() {\n  // Implement compression logic here\n  console.log('Compression logic goes here.');\n}\n\nfunction decompress() {\n  // Implement decompression logic here\n  console.log('Decompression logic goes here.');\n}\n\nswitch (args[0]) {\n  case 'compress':\n    compress();\n    break;\n  case 'decompress':\n    decompress();\n    break;\n  default:\n    console.log('Invalid command. Use compress or decompress.');\n    break;\n}\n\nconst ig = ignore();\nconst gitignoreRules = readGitignore();\nig.add(gitignoreRules);\n\nconst dirPath = cbjConfig.dirPath;\nconsole.log('Read files recursively from:', dirPath);\nconst filesData = readFilesRecursively(dirPath, ig);\nconst jsonContent = JSON.stringify(filesData, null, 2);\n\nfs.writeFileSync(cbjConfig.outputFileName, jsonContent);\nconsole.log(`Files data written to ${cbjConfig.outputFileName}`);\n"
    }
]